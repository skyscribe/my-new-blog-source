---
layout: post
title: HTTP/2和gRPC - 微服务时代的应用基础协议
comments: true
categories: [design, protocol]
tags: [design, architecture, microservice]
---

大部分的规模较大的商业应用软件后端系统如今都采用了分布式软件架构，并沿着SOA -> 微服务 的路径在往前演进；并按照领域驱动设计的绑定上下文的设计思路来切分服务；
服务之间的接口则不约而同地选择了HTTP协议作为基本的交互协议，背后的原因很大一部分应该来自于HTTP协议简洁、清晰的设计（尽管功能非常复杂）和随手可得的协议栈实现。

可惜HTTP协议并不是完美无缺的选择，Google早就在Chrome浏览器中尝试去改进HTTP/1.1协议中的一些不足并提出了开放的SPDY协议；这一尝试基本为HTTP/2的提出铺平了道理。
同时在Google内部，Protobuf作为其内部的跨语言接口定义语言已经被使用了很长时间；在Google之外的一些商业组织中，Protobuf也得到了广泛的应用。
两者的结合则已经对微服务基础设施领域增添了新的可能性。

<!--more-->

## HTTP协议

HTTP协议是现金的**互联网服务的基础协议**，是互联网的基石之一；从TCP/IP的协议栈结构上来说，它是工作在应用层上的协议。
它的基本通信模型遵循的是**请求/响应式**通信模式，通信的双方中有一方被称为服务器放，对外提供服务并接收HTTP请求；而另外一方则称为客户端方。
一次协议交互总是从客户端发起请求开始，然后服务端收到服务请求，根据后台的资源情况做相应处理，返回结果给客户端，完成一次服务。

HTTP服务器对外提供服务，因此也往往将其上的服务成为是Web Service。复杂的应用程序的一次服务可能需要多条强求/响应交互才可能完成，
这种情况下基本的请求/响应模式还是不变的；尽管多个请求之间可能按照流水线的方式做优化，形成pipeline。

### HTTP的设计特点和历史

HTTP协议的设计遵循**典型的Unix设计哲学**, 为了保持协议使用上的简单和可扩展，使用文本流作为协议的内容编码；
这样调试和互操作就变得简单易行。其它一些应用层协议可能采用二进制的格式来编码，可能带来比较高的效率和较小的带宽压力，
然而不同的编程语言可能处理起来就有不同的门槛（尤其一些脚本语言处理起来就比较麻烦）；而文本流是所有的编程语言都能轻松处理。
如果要对程序的行为进行分析和调试，文本协议因为是肉眼可读的，大部分情况下不需要额外的工具就可以对抓包的数据流进行分析；
应用开发的效率就比传统的二进制协议高的多。为了方便服务器关注于具体的业务而无需过多关注底层的传输细节，
HTTP协议采用TCP可靠流传输协议以确保上层发送的消息总是能可靠地传递给对方。

协议结构上看，请求消息和响应消息都遵循相同的整体结构
- 头部包含请求资源的路径信息或者响应消息的状态码、协议版本等信息作为起始行
- 头部的其他部分包含一系列用空行隔开的一个或者多个头，每一行中包含一个头的名字和对应的值
- 可选的消息体，和前面的头部之间有一个额外的空行（即和其它的头之间多了额外一个空行）

早期的HTTP协议需要解决的问题往往比较简单；毕竟早期网站上的服务内容也比较有限，并且往往是静态的文字或者图片，
早期的Web应用带有明显的文件访问的烙印：客户端发起请求访问服务器上的文件或者图片，服务器端收到HTTP请求之后，
去本地机器上查找相应的资源，然后将资源包装在相应消息中返回给客户端。这种简单场景下，简单的文件存取加上访问控制就可以轻松应付了。

这种情况下，资源的类型可能有多种多样的，HTTP协议采用已经在电子邮件协议中得到广泛应用的MIME协议来描述所要访问的资源类型；
服务器端将找到的资源放在相应消息中返回，并在头部放置资源的类型。客户端在收到消息后，会先检查头部，确定类型后在决定如何解析内容。

90年代中期网站上的动态内容逐渐增多，这个时候需要访问的资源可能就不仅限于静态的文件或者图片，而有可能是一些虚拟的资源，
如数据的报表或者存放在数据库中的数据的索引或者查询结果；开发效率的优势催生了Perl为主流的CGI技术的流行：
服务器端在收到请求后，根据资源请求调用外部提供服务的CGI脚本，这些脚本符合CGI接口并符合**同步处理逻辑**，访问具体需要处理的资源，
并将结果写入在标准输出中，HTTP底层服务器则会接收改程序输出，原封不动地反馈给客户端。

这里服务器端的**设计方法是同步的**：每次过来一个请求，服务器端就新创将一个进程，调用对应的CGI脚本处理，产生输出之后，
该请求的处理被转交给底层的HTTP服务器，返回给客户端。CGI的方式在并发服务数逐渐增多的情况下会产生明显的性能问题，
因为操作系统创将大量进程的开销是很可观的；加上由于服务器在调用CGI开始到CGI返回之前都必须保持阻塞，请求数量大了之后，很容易就产生瓶颈，
导致系统资源消耗在IO等待上，无法发挥CPU的计算潜力。

FastCGI技术的出现试图用技术手段缓解CGI技术的不足；FastCGI不再死板的对每个HTTP请求创建新的进程，而是总共就启动一个后台进程，
并通过一个特定的后台socket服务和Web服务器本身进行连接；这样每次有新的请求过来的时候，HTTP服务器将请求内容交给FastCGI后台进程，
由该进程进行处理后，将输出再反过来交给服务器。由于仅有一个进程在处理所有的请求，创建进程的开销，以及多个进程切换上下文的开销就可以得以节省。
同时，一些HTTP服务器提供了类似于mod_perl/mod_php等扩展技术来优化CGI，所不同的是，该技术可以将对应的语言解释器嵌入到HTTP服务器中，
避免脚本语言解释器启动的开销;同时在提升性能的情况下复用之前写好的CGI脚本。

Web技术的深入发展催生了许多新的可以处理HTTP协议消息的中间件，如代理服务器、安全网关等技术；这些中间件会按照HTTP协议的规范，
对HTTP协议的头信息做一些额外的处理，但往往不会改动消息体中的媒体内容。
早期的HTTP/1.0版本默认会在一次请求响应交互结束之后，就关闭当前的socket连接；下次再要请求资源，就必须创将一条新的连接出来。
这样不仅效率低下，而且会对中间代理带来了挑战，因为这些中间结点本来是需要尽可能地做到对客户端和服务器端透明不参与连接状态管理的。

安全问题是另外一个日益引起人们重视的话题，而早期的WEB内容几乎都是明文传输的，任何人都可以在网络上窃听、监视甚至修改服务器和客户端之间的通信；
隐私和敏感信息完全得不到保护。后来套接字层面的SSL已经TLS技术被引入到HTTP协议中来，在发起HTTP报文之前，先建立安全的套接字连接，
或者可以根据重定向或者挑战、响应的方式建立安全的HTTP连接。这一过程可能是比较耗时的，每次都重新建立新的HTTP连接显然效率低下。

HTTP/1.1通过默认将底层连接设置为持久性连接来解决这个问题：除非指定了 Connection: close 头，默认的HTTP连接都是长连接；服务器端在送回响应消息后并不会主动关闭连接。
这样下次请求再来的时候，依然可以使用之前已经打开的连接，减少TCP协议栈启动时候滑动窗口自适应算法引起的延迟，从而使得内容可以尽快地发送给客户端。
大部分HTTP流量都被传送给客户端用以显示，更快的处理速度就意味着更快的页面反应、加载速度。
在TLS更加流行的今天，长连接的好处是TLS会话建立或者恢复（在前一个会话仍然可以被复用的情况下对应的会话块会被协商复用）的时间开销。

典型的情况下，一个复杂一些的网页页面在被打开的瞬间，浏览器可能会同时发起几十乃至上百条连接请求资源，并在资源被发送到客户端之后，再进行加载和渲染显示。
很多情况下，某些资源可能来自于同一个资源服务器（可能是某些CDN、缓存或者后台同一个负载均衡节点，但并不一定是处理HTTP请求的机器），采用严格顺序地请求资源，
即使有上述的长连接优化，一来一回的时间开销也相当可观。HTTP/1.1 支持pipeline来优化这种情况

![http_pipeline](https://www.w3.org/Talks/970210HTTP/pipeline.gif)

这种情况下，发送方可以对同一个服务端的同一条连接，同时发起多个请求消息而不必等待响应消息的返回；同时请求消息之间，以及对应的响应消息之间任然保持严格的顺序关系。
所不同的只是发送消息的时间进行了优化。这种情况下，有一个潜在的风险，即如果第一个响应消息返回了错误，那么后续发送的请求都被认为是失败的。

### HTTP/1.1的不足

上述的pipeline特性虽然优化了数据的往返传输时间，但并不能满足日益严苛的需求；因为协议本身顺序、同步的语义中暗藏着一个经典的HOL问题：
HTTP服务器返回的响应消息必须严格按照请求的顺序发送给客户端。这意味着服务器端必须强制顺序的处理逻辑；
如果服务器端采用多线程或者异步编程的范式并发的处理请求并不按照同样的顺序返回响应，那么客户端就不能正常处理这些响应。

改问题在传统的交换设备



### HTTP/2的特点

### TLS的争议

## gRPC项目

### RPC协议的由来

### gRPC

### 其它开源RPC中间件

## 参考
1. [How does HTTP/2 solve the Head of Line blocking (HOL)](https://community.akamai.com/community/web-performance/blog/2017/08/10/how-does-http2-solve-the-head-of-line-blocking-hol-issue)
