---
layout: post
title: 用Java Flight Recorder来调优JVM性能
comments: true
categories: [programming, debugging]
tags: [programming, tuning, java, debugging, performance]
---

随着Java程序在后端压倒性的普及，其性能本身早已经无人质疑；然而一个经常不为人道的事实是，Java平台上的程序不是天然就具有很高的性能；
因为Java语言显著降低了程序员的准入门槛，真正到系统性能这一块，仍然需要大量的调试和优化，即所谓的JVM性能调优。

Java Flight Recorder（后文简称JFR）是Oracle官方推出的商业环境的性能调优利器；其本身对运行期系统的侵入性很小，同时又能提供相对准确和丰富的运行期信息；
合理使用改工具可以极大地提高工作效率。本文就个人工作环境中的一些实际使用情况做一简单的总结。

<!--more-->

## 基本工作模型和采样

JFR本身是基于周期性对JVM虚拟机的运行状况进行采样记录的，其采样的频率可以通过其参数传入;只是需要留意的是，采样间隔越小对系统的性能干扰就越大。
和传统的JProfiler/VisualVM这些基于JMX的工具所不同的是，JFR记录的信息是**近似而非精确**的；当然大部分情况下这些**模糊性信息就足够说明问题**了。
对于大部分场景下，这些近似信息反而可以更容易发现一些真正的问题。

要想使得JFR能够产生采样信息，首先需要确保你采用的JVM是Oracle的JVM，否则JFR也不认识虚拟机的内部工作机制；此外还需要在JVM的启动参数中开启商业特性的开关，
并开启JFR；相关选项很容易在官方文档里找到，这里就不赘述了。
额外需要注意的一点是，你必须有**Oracle的商业使用许可**，否则是不能用的。

开启JFR选项后，有两种方式可以产生采样文件以便时候分析
- 在启动参数里指定启动后即开启采样；这种方式对于想分析启动时候性能的情况非常有用；只要在参数中指定采样间隔，时间以及保存的文件路径即可
- 通过`jcmd`的JFR命令来按需产生采样；该方式更适合在程序启动之后按需产生采样。Oracle JDK自带的Java Mission Control程序可以挂在本机上运行的Java程序上做观测，
本质上也是这种机制。

产生的采样文件可以在本地机器上使用Java Mission Control工具打开做事后分析。

## 哪些信息被采样保存
基本上所有有用的信息都被保存下来了；最主要的概要信息保存在`General/Overview`里边。

### General面板

以下是一个具体的CPU在某段时间出现繁忙的例子，这种采样在繁忙的后端服务器上可能是比较常见的，因为大部分情况下我们需要**尽可能占尽可用的CPU时间来追求更高的吞吐率**。
当然如果CPU已经满负载运行，而吞吐量又不太理想的时候，详细深入的分析就变得更为重要。
![an example program's overview with hot cpu](/assets/images/jfr/jfr_overview.jpg)

首先映入眼帘的是一个常常的时间轴和系统时间图，开始时间和结束时间都可以按需选择；
如果选定了synchronize selection,则所有的**信息显示都会随着选择范围的变化而实时刷新**。
这一机制非常灵活有用，因为很多时候我们都需要根据基本分析和直觉印象去选择某些特点的时间来对比观察。譬如在追求高吞吐率的场合，发现CPU没有用满但是吞吐率有上不去的时候，
可以选择CPU有锯齿的地方，详细去查看特定的时间点内发生了什么。

接下来的三个大大的仪表盘会给出Java的堆内存、CPU使用、GC停顿时间的平均值和最大值；从而可以看到系统在给定时间内，JVM的内存/GC情况和CPU利用概况。

最下方的部分则会显示一个更详尽的CPU使用图表曲线，在任何一个时间点（依采样频率而定）机器总的CPU利用率、JVM和用户程序在用户态、内核态的CPU使用情况。
对于追求高吞吐率的后端程序而言，这些信息值得仔细查看。

最后一部分则显示了JVM的概要信息，包括其启动时间，JVM的具体版本等。除了这个概要页面，还有2个总体的标签页，分别显示具体的JVM命令行选项（包括默认没有设置但是传入给JVM的项），
JRE环境的属性和变量，采样记录信息如线程上下文切换计数的时间间隔等；这些信息在分析一些具体的性能参数的时候，是很重要的参考。

### 内存面板
由于Java中的内存分配和回收是JVM帮助程序员做的，Java性能调优的很大一部分工作是和内存调优密切相关的。
内存面板则是根据运行期的采样数据将JVM的GC相关的数据汇聚显示出来；和其它的类似，同样是顶层的时间轴曲线可以依据选择来同步其他图表。

中间的部分显示详尽的内存使用概览，包括总共可用的机器物理内存、已经使用的物理内存、提交给OS的堆空间、已经使用的对空间等。
锯齿状的曲线就是已经使用的堆空间随着GC的活动而动态变化的历史。如果图表中出现**比较粗的“柱子”**图样，则表明GC的工作情况需要具体仔细查看了。

最下栏则显示了当前GC的配置情况，如初始、最大的堆空间大小，不同的代的空间分配、GC活动的统计技术以及空间分配的概要情况。
大部分情况下，我们更多关注运行过程中间的**GC统计指标**，包括总共的收集次数，最小、最大以及平均的停顿时间；
这些数值当然都是越小越好了；因为任何的GC活动都会挤占应用程序的可用资源。

#### GC活动信息和收集细节
一些额外有效而更细节的信息则会显示在单独的标签页中，包括这么几类
- 垃圾收集详细信息：所有的GC活跃情况，以ID为标号详细地显示出对应的停顿时间，收集的类型，回收的原因，开始/结束时间，以及统计性的最长停顿时间等。
这些信息很多和**具体的GC算法是密切相关**的
- GC的停顿情况：同样针对的是每一个GC活动，针对具体的回收事件，对具体引用类型的收集停顿间隔以及相应停顿处理活动的开始时间信息等；
虽然不能看出具体的回收对象，但也足以看出大概的整体停顿比例和时间，对耗时的GC活动**做定性的分析**还是足够有用的
- 对象引用情况：简要的显示了某次GC活动的时候，各种类型的对象引用的个数，可以辅助上一项，提供了更细节一点的数量统计
- 堆空间的变化情况：回收前后的堆空间情况，和`jstat`提供的信息一样

下图是上面同一个采样的GC信息，其中可以看出GC的活动对于CPU繁忙时段的贡献是不大的，基本可以排除GC对性能的影响
![GC activities](/assets/images/jfr/jfr_memory_gc.jpg)

#### 详尽的GC时间统计信息
GC时间统计页面则从时间的角度给出各个GC的代在收集过程中所占用的时间，最小、最长、平均停顿等。
这些统计同样是按照新生代、老生代、以及所有的收集活动耗费的时间来呈现的。同样这些信息**和具体的GC算法是密切相关**的，需要根据GC算法的配置来综合使用。

同样是上面的程序运行期的一个采样，其GC时间信息如下
![GC times information](/assets/images/jfr/jfr_memory_gc_times.jpg)

上述采样表面，大部分GC活动事件属于新生代GC，即回收临时对象的常规动作；老生代GC仅仅有3次，并且占用的时间并不算长。
注意这里采用的是G1 GC算法，**老生代的回收并不会完全阻塞应用程序线程的运行** - 具体的时间信息可以结合应用程序的log时间戳打印综合确认。

#### GC算法相关的具体配置细节
GC算法的参数配置则可以在其相邻的标签页找到，它给出了更为详尽的算法配置参数，包括
- 新生代、老生代对应的收集算法
- 并发收集的线程个数 （可能对某些算法不适用）
- 是否开启并发收集
- 是否允许应用程序显式地调用GC
- GC被允许运行的时间占所有可用CPU时间的比率的上限值（G1等新型的GC算法支持这种约束，防止GC过分活 跃）
- 各个代的空间信息，包括初始空间大小、最小对空间大小、最大空间大小，以及对空间的地址大小、指针压缩情况和对象对齐情况（对**64位的Java程序尤为重要**）。
新生代的配置还会提供诸如TLAB空间占用的情况和配置，以及默认隔多长时间会将仍然在引用的对象挪到老生代等信息。

同样是上面的采样，其GC配置信息如下
![GC parameters configuration](/assets/images/jfr/jfr_memory_gc_cfg.jpg)

以上这些复杂的信息对于深入的内存分析和针对是非常宝贵的;
譬如如果应用程序中生存期较长的对象并不多（面向对象设计提倡**大部分的运行期对象是朝生夕死**），然而老生代却有比较大的压力，
就要怀疑是否是部分关键逻辑运行时间过长，导致经过数次新生代回收之后，仍然没有被释放出去，从而导致进入老生代被老生代的回收活动处理。

### 代码面板
代码面板则是基于采样得到的信息的代码执行情况给出统计分析结果。
需要注意的是，所有的数据都是依据具体的采样点，具体的**线程当时正在运行的的函数调用栈的具体状态来计数**并累加的。
比如某个调用栈有10次被捕获到，那么相应的栈上的所有的函数的计数都会被记为10；这样得到的结果和**实际代码的CPU占用率比较类似**，但是并不完全精确。
所有的百分比数值都是相对百分比，其计算方法是用当前函数的采样数和整体（线程或全局CPU采样数）的采样数相除。

#### 代码概览
概览页面会显示按照Java的包情况统计的采样数和相对总体的百分比；可以按照具体的列点击排序。最下边的视图则显式热点的类列表。
同样这些视图都可以根据选定的时间间隔来同步数据，使得我们可以方便的按照具体时间来分别查看CPU被占用在什么地方。

以下是上述采样的代码概要视图
![code overview](/assets/images/jfr/jfr_code_overview.jpg)

**TBD**
#### 热点的调用栈、

#### 热点方法

### 线程面板

#### 热点线程

#### 线程竞争和上下文切换情况

#### 时延和锁竞争情况

#### 线程Dump情况

### IO情况

### 系统信息和事件

**TBD**
