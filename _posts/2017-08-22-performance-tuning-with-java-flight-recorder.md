---
layout: post
title: 用Java Flight Recorder来调优JVM性能
comments: true
categories: [linux, programming, debugging]
tags: [linux, programming, tuning, java, debugging, performance]
---

随着Java程序在后端压倒性的普及，其性能本身已经无人质疑；然而一个经常不为人道的事实是，Java平台上的程序不是天然就具有很高的性能；因为Java语言显著
降低了程序员的准入门槛，真正到系统性能这一块，仍然需要大量的调试和优化，即所谓的JVM性能调优。

Java Flight Recorder（后文简称JFR）是Oracle官方推出的商业环境的性能调优利器；其本身对运行期系统的侵入性很小，同时又能提供相对准确和丰富的运行期信息；
合理使用改工具可以极大地提高工作效率。本文就个人工作环境中的一些实际使用情况做一简单的总结。

<!--more--!>
## 基本工作模型和采样

JFR本身是基于周期性对JVM虚拟机的运行状况进行采样记录的，其采样的频率可以通过其参数传入;只是需要留意的是，采样间隔越小对系统的性能干扰就越大。
和传统的JProfiler/VisualVM这些基于JMX的工具所不同的是，JFR记录的信息是**近似而非精确**的；当然大部分情况下这些**模糊性信息就足够说明问题**了。
对于大部分场景下，这些近似信息反而可以更容易发现一些真正的问题。

要想使得JFR能够产生采样信息，首先需要确保你采用的JVM是Oracle的JVM，否则JFR也不认识虚拟机的内部工作机制；此外还需要在JVM的启动参数中开启商业特性的开关，
并开启JFR；相关选项很容易在官方文档里找到，这里就不赘述了。
额外需要注意的一点是，你必须有**Oracle的商业使用许可**，否则是不能用的。

开启JFR选项后，有两种方式可以产生采样文件以便时候分析
- 在启动参数里指定启动后即开启采样；这种方式对于想分析启动时候性能的情况非常有用；只要在参数中指定采样间隔，时间以及保存的文件路径即可
- 通过`jcmd`的JFR命令来按需产生采样；该方式更适合在程序启动之后按需产生采样。Oracle JDK自带的Java Mission Control程序可以挂在本机上运行的Java程序上做观测，
本质上也是这种机制。

产生的采样文件可以在本地机器上使用Java Mission Control工具打开做事后分析。

## 那些信息被采样保存
基本上所有有用的信息都被保存下来了；最主要的概要信息保存在`General/Overview`里边。

### General面板
首先映入眼帘的是一个常常的时间轴和系统时间图，开始时间和结束时间都可以按需选择；如果选定了synchronize selection,则所有的信息显示都会随着选择范围的变化而实时刷新。
这一机制非常灵活有用，因为很多时候我们都需要根据基本分析和直觉印象去选择某些特点的时间来对比观察。譬如在追求高吞吐率的场合，发现CPU没有用满但是吞吐率有上不去的时候，
可以选择CPU有锯齿的地方，详细去查看特定的时间点内发生了什么。

接下来的三个大大的仪表盘会给出Java的堆内存、CPU使用、GC停顿时间的平均值和最大值；从而可以看到系统在给定时间内，JVM的内存/GC情况和CPU利用概况。

最下方的部分则会显示一个更详尽的CPU使用图表曲线，在任何一个时间点（依采样频率而定）机器总的CPU利用率、JVM和用户程序在用户态、内核态的CPU使用情况。
对于追求高吞吐率的后端程序而言，这些信息值得仔细查看。

最后一部分则显示了JVM的概要信息，包括其启动时间，JVM的具体版本等。除了这个概要页面，还有2个总体的标签页，分别显示具体的JVM命令行选项（包括默认没有设置但是传入给JVM的项），
JRE环境的属性和变量，采样记录信息如线程上下文切换计数的时间间隔等；这些信息在分析一些具体的性能参数的时候，是很重要的参考。

### 内存面板
由于Java中的内存分配和回收是JVM帮助程序员做的，Java性能调优的很大一部分工作是和内存调优密切相关的。同样顶层的时间轴曲线可以依据选择来同步其他图表。

中间的部分显示详尽的内存使用概览，包括总共可用的机器物理内存、已经使用的物理内存、提交给OS的堆空间、已经使用的对空间等。
中间显示的锯齿装的曲线就是已经使用的堆空间随着GC的活动而动态变化的历史。如果图表中出现比较粗的“柱子”图样，则表明GC的工作情况需要具体仔细查看了。

最下栏则显示了当前GC的配置情况，如初始、最大的堆空间大小，不同的代的空间分配、GC活动的统计技术以及空间分配的概要情况。大部分情况下，我们更多关注在中间的GC统计指标，
包括总共的收集次数，最小、最大以及平均的停顿时间；这些数值当然都是越小越好了；因为任何的GC活动都会挤占应用程序的可用资源。

