---
layout: post
title: 读Uncle Bob新书之Clean Archtiecture
comments: true
categories: [architecture, design, study, notes]
tags: [design, programming, language, architecture, pattern, engineering]
---

不经意发现Bob大叔出版了新书，延续之前的命名风格定名为《Clean Architecture》，英文版已经于2017年底正式上市；
刚好公司的账户可以访问Orielly公司的在线书城，于是就断断续续地读了起来。
Bob大叔讲故事的能力即使在久负盛名的技术作家圈里面也是闪耀出众的，可以算作是高手中的高手，行文由浅入深层层递进，可读性一向很好，这本书读起来也不例外。

<!--more-->

## 历史的回顾和架构师的主要职责

作者在一开头就用讲故事的手法描述了一个要求保持匿名的市场领先的软件公司的例子来讲述软件架构失败可能带来的巨大危害 - 一个庞大的具有超过六百万行代码的项目，
因为明显的架构问题导致8年的时间，项目组的人手越来越多，开发和添加新的功能的成功却又直线上升导致虽然增加了很多的人手却不能得到相对应的产出；
这样的问题也就是很多书里所讲的**可扩展性不足**导致的修改困难。

### 架构师的工作重心
回头说起来软件项目和硬件项目的不同，Bob大叔认为这里主要的不同就来自于软件是可以被修改的，而硬件项目则是一旦完工就无法很容易地扩展和添加新的功能。
软件架构师的主要核心职责**不在于功能性的需求如何被实现出来，而是如何监控和设计软件系统的结构**使得添加新的功能保持简单、经济和高效。

虽然作者没有明确地提到，但是我们还是需要注意功能需求也是很重要的，因为很多架构的约束反而是来自于系统的功能性需求；
只是现实生活中，大部分的项目经理和管理人员更容易看到功能需求的问题，而不会特意关注系统结构上的约束，那么我猜这里作者有意不提这方面也算合理，
读者却不可不自己心神领会；如果生搬硬套就会走向歧路了。

### 计算机行业的历史

讲起历史来，Bob大叔绝对算是行家中的行家；当初他的《Clen Code》系列视频中每一节都会加入一小部分关于天文学和物理学的历史知识作为铺垫；
甚至于我一度以为大叔是学理论物理学或者科学史出身的（后来在其它的演进里面才发现不是）。为了讲述和探讨软件行业的本质工作性质，作者又不吝文墨地回顾了整个计算机程序设计的历史；
作者给出的结论是，真正**本质的计算机技术和程序设计思想在过去的几十年中并没有发生太大的变化**。

这可以说是一个既乐观又悲观的消息。好的方面是，行业经过几十年的摸索和积淀终于积累下来了很多供后辈好好重用的宝贵经验；
可悲的地方却是商业上的超级多的**浅层次的成功反而使得真正的技术被大部分人忽视**了。
工业领域的应用招致了很多不懂计算机核心技术的软件工程师，用不太严谨的做法堆砌出大量的代码，而真正的生产模块化的代码的技术和方法都是在**想方设法限制程序员的能力**。

### 编程范式的历史
虽然编程的本质是一样的，业界却先后流行起来三种变成编程范式，对这些范式的支持情况的不同导致了各种形形色色的编程语言的繁荣；
但是仔细琢磨的话，我们会发现这些编程语言虽然外表看起来千差万别，分解之后里面的核心特性却没有多少。

面向过程的编程范式是很多人非常熟悉的范式，早期的先驱们（尤其是荷兰的牛人Dijkstra从理论物理专业转行来演进计算机理论）总结了几种基本的结构，
并不惜通过在**一片争论声中将Goto关入牢笼**来强迫大家**采用事先定义好的顺序、分支和循环三种控制流转换**，编写出良好的软件。
因为硬件执行过程的贴切的模拟对应，面向过程的编程范式一直是程序员的基石。

面向对象的编程范式其实并没有干太多新的事情，它里面总结的各种套路其实面向过程的方法也可以做到。
有人总结了面性对象的本质特性是继承、封装和多态，然而本质上面向过程的语言用结构和函数指针的方法一样可以达到，
甚至早期兴盛的C++语言就是通过虚函数表这一机制，在底下生成额外的控制带来控制程序逻辑跳转。
从这个意义上来看，面向对象的编程范式其实是限制了程序员必须用**间接控制流转移**的方法来提高可维护性。

函数式编程范式则是很早的一个范式，众所周知它的历史可以追溯到和图灵同时代的逻辑学家邱奇的lambda算子推演。
这一思路的主要特征就是**数据的不可变性**，同样的数据经过同样的处理必然产生同样的输出，同时数据一旦产生就不能被修改了，否则就会有副作用。
这种范式之所以能够再度流行起来，恰好又是因为更为复杂的运算需求需要增加数据之间的隔离。
前两种范式里面都有很明显的变量和赋值、操作的基本机制，而这一机制在函数式范式面前毫无用武之力。

软件架构师的任务就是需要清楚地认识到这些编程范式**只是在不同的维度上对程序员加了各种各样的约束**，以解决它所适应的场景的问题而已。
理顺问题的场景然后清楚地了解编程实现和交付中的各种困难，减小软件扩展和维护的成本，是架构师所面临的最根本的挑战。

### 计算机为什么是一门科学
作者不惜花费大量的笔墨来跟踪Dijkstra大师的人生轨迹和研究成功，其实是想为他最后的结论做铺垫，搞明白计算机能否成为严谨的数学。
毕竟早期的计算机先驱们都是数学家乃至逻辑学家；他们都期望找到一种严格的方式来证明计算机程序的绝对正确性。
现在大家都已经明白，这种努力无论从理论上还是时间上都已经破产了。

计算机软件和编程工作只能被认为是一种科学而不是一种数学。科学的主要特征是，你永远无法证明某个事情是真的，
但是却可以用固定的重复手段去验证该事情，并有可能有一天发现这个事情不成立而推翻这个结论。
这个**证伪的方式其实就是我们所做的软件测试**；我们有各种方法做形形色色的测试，而测试不通过的时候，我们可以通过修改程序来变更程序的行为，使得它贴合我们的期望。

想通过分析和推倒来写出严格的没有问题的程序虽然没有指望了，我们仍然可以通过降低测试的成本，改进测试的手段和方法，
通过持续、自动化的测试和即时反馈的方法提高工作效率。这方面的思考对于架构师而言是不可或缺的。

## 模块设计的原则和SOLID

架构师所关心的应该是更高层次的抽象实体而不再是一样一行具体的实现代码，因为**唯有关注于这些做过良好分离的抽象，才能做到纵览全局心中有数**。
这些抽象实体之间的关系是架构师需要重点考量的；这个过程中需要用到的设计原则并不拘泥于某种编程语言或者编程范式，尽管这些设计原则是在长期的面向对象思想中被提炼总结出来的
- 单一职责原则
- 开发闭合原则
- 李氏替换原则
- 接口隔离原则
- 依赖导致原则

这些设计原则以前一直被成为是面向对象的设计原则，一个很重要的原因应该是面向对象设计曾经风靡二十年之久；可惜的是**大部分死背概念的架构师并没有真正的理解这些**设计原则。
Bob大叔则旗帜鲜明地说**这些原则其实都需要仔细地来揣摩和理解**，单单是粗浅的重复字面意思而不能灵活地应用，无异于是买椟还珠，空入宝山徒手而还了。

### 设计原则的目标和场景
这些设计原则的目的是帮助我们实现简单而又可靠的软件模块乃至子系统，使得
- **变更它们的成本很低**，因为软件系统总是要添加新功能才更有生命力，修改困难的软件就会被慢慢放弃了
- **理解起来容易**，因为维护软件总是需要人来做，而参与其中的人总是在流动的
- **可以被轻易地重用在合适的地方**，因为永远也没有人可以预测未来的软件项目需求；重头再写类似的代码的代价又过于高昂

上述的五大设计原则往往被认为是处理复杂软件系统内处于**中等抽象的实体结构和相互关系**的指导性方法论。
这些中等粒度的抽象就是一般意义上所说的模块或者子模块；不同的模块或者子模块之间会按照这些原则来聚合而形成基本的可执行单元。
在不太复杂的软件系统中，做到这一层就可以满足所有需要了；更复杂的大型的软件系统可能需要更高层次的组合，即组件。

### 关于设计原则的简单概括和去谬

简称为SOLID的五大设计原则对于现金的架构师而言都不是什么秘密了，然而对他们的认识上的谬误还是随处可见。作者又不惜花费一个大的章节来详细阐述其中关键的思想。

#### 单一职责
最简单却又被误解最深的一个原则非单一职责原则莫属了；很多人的第一印象解读就是，一个模块应该只做一件事儿并讲这件事儿做好。
粗看起来这个解释很切合题中之义，也能在Unix编程哲学中找到KISS原则的呼应。只是这一原则的提出其实有更深刻的考虑因为**怎么去界定前面所说的一件事儿**会非常困难。
单一职责的真正含义是:
> 一个模块**被改变的原因应该有并且只有一个**；或者说一个模块的**利益相关者应该有并且只有一个**。

不幸的是，这里面的原因也好，利益相关者也好，都还是有含糊而解释不清的地方，因此作者毋宁说：
**一个模块和他相关联交互的Actor只有一个**，这样用UML描述模块关系的时候就比较清楚的看出这一原则有没有呗违反了。

#### 开闭原则

开放闭合原则倒是没有那么多的误解，因为它本身就是事关怎样划分子系统、子模块乃至基本单元的。它所要求的系统应该对修改闭合对扩展开放某种程度上可以看做是对模块高内聚的要求。
要做到这一点，需要讲系统划分为不同的抽象层次的模块、子模块，并且实现良好的约束使得高层的模块不要以来于低层的实现，而**扩展系统的方式总是维持核心模块的稳定性再增加新的低层模块**来完成。

#### 李氏替换原则

李氏替换原则原本是来源于类型系统的定义；一般也不太会被理解错误，只是在软件设计和架构中，这里的**类型被替换成了设计中的抽象**并加以深入考量。
对于有类型的静态语言来说，这意味着接口或者基类的抽象需要有足够好的普适性，扩展出来的子类必须完全遵守事前定义好的契约，因为这里的**耦合是非常强**的。
对于弱类型的动态语言而言，这些约束可能是隐式的，虽然因为不必有源代码依赖上的麻烦而变得更加灵活，但是同样因为没有这些检查而使得所有违反约束的错误代码都只能在运行时才能发现。

某种程度上说，缺少了编译器的检查，**动态语言易于修改代码的优势其实带来了维护设计一致性的额外麻烦**；这一点不可不察。

#### 接口隔离原则

接口隔离原则强调的是模块化软件关于耦合方面的分离；它的最基本的思想可以认为是：
> 除了你必须要以来来完成模块定义的功能之外的东西，额外的依赖都不要引入进来。

这里的要求是两个方面的
1. 提供功能的模块在对外提供的接口上必须保证是高度内聚的，在对应的抽象等级、粒度上给出的接口需要职责明确
2. 使用接口的模块需要保证只引入自己使用的功能，而不能引入不必要的依赖

#### 依赖倒置原则

这个原则可以看作是传统的面向对象设计里面最为烧脑的一个原则，正确理解起来一直有些不容易，因为必须**同时考虑到代码结构的组织和实际运行时的依赖来看**才能体会其中的精妙。
它的核心是将程序组织的依赖和运行时的依赖跟分离开来看，构造代码的时候，从抽象角度来说需要保证
- 抽象层次高的代码必须依赖于抽象而不是具体实现；
- 实际的具体实现的代码就只能看到这些抽象而看不到抽象背后所隐藏的实现；
- 核心模块的业务规则只能看到其它外围模块的概念抽象，而看不到具体实现这些抽象的实体；这样当需要扩展新的实现方式的时候，只需要添加新的实现代码，而**核心的业务规则可以保持稳定**。

可以看出依赖导致原则其实潜在地暗含了其它几个原则。实际实现中还需要考虑下面一些因素
- 操作系统和平台软件的一来是不可避免的；但是这里的关键是期望减小系统的维护成本，
而这些底层的稳定的部分很少变化，所以直接依赖他们的具体实现倒是也问题不大；
如果是自己内部搭建的通用平台软件，那么则需要另外分析和斟酌；这方面的讨论也有很多。
- **核心业务逻辑层的稳定提炼需要依赖于领域知识**，因为什么是稳定的什么是可变的跟具体的目标业务场景息息相关，没有放之四海而皆准的模板可以套用。

## 组件设计原则

组件化技术已经成为搭建大型复杂软件系统的基础技术，如何组织系统的组件子系统，安排好这些子系统之间的接口、依赖和交互关系是软件系统架构师的主要工作职责。
需要留意的是，这些技术是**构建在基本的模块化设计开发方法之上的，因此很多模块设计的原则也被自然而然地升华和适配**；如果不能深刻地理解基础的模块化设计方法和里面的痛点，
生搬硬套组件设计的方法弄不好就会弄巧成拙，变成浮沙之上筑高台的游戏就很容易招徕失败。

### 组件化技术的探索和演化历史
组件作为复杂的软件系统发布和部署的基本单元，其形式随编程语言和平台的研究和发展而呈现不同的具体形式，可能是Java环境中的Jar打包文件，
或者是.NET环境中的动态库文件，也可能是Ruby中的Gem，Rust中的模块，NPM中的模块等。
它们的共同特征就是**可以独立打包、发布，并且和其它组件有形形色色的依赖共生**关系。

最早期的家算计程序不支持这些概念，所有人开发的源代码必须安置好在内存中被加载的位置，多人协作的场景下，
大家协商好自己负责的部分的加载地址，但是这种很快就变得难以为继；
于是新的可以支持重定位加载地址的技术就被发明出来，使得不同的程序可以在加载的时候，加载器通过计算给它安差一个位置，防止冲突。
这种情况下，编译出来的程序的实际加载位置是未知的，而加载器需要根据它的算法为一个可执行文件中的所有的动态加载地址计算一个没有冲突的方案来。
链接器则被用来对编译的程序安插一些可重定位的段和符号表，以便加载器在程序实际载入内存的时候安插实际的内存地址。

摩尔定律和墨菲定律的交替作用始终影响着计算机软件行业的发展和演进，程序的规模变得越来越大，业务系统越来越复杂，而新技术的出现总是被现实中遇到的限制所驱动。
传统的静态语言中，用连接器和加载器技术组织的组件化技术依然有各种各样的优势和不足，间接催生了采用不同技术决策的技术的繁荣共存；
同时希望绕开这一限制的先驱们则通过创建新的编程语言（如动态语言）或者平台技术（跨越多种语言的中间语言来促进互操作）来简化组件化开发的种种问题。

现在我们可以支持在程序执行的过程中，**不重启主要系统，而将新开发的功能插入运行的系统中的办法**来实现功能的实时更新和扩展，
这种插件化技术甚至在很多开发环境中成为默认的扩展方式；这一技术能够工作的前提是系统的架构必须有良好的考虑和组织。

### 组件内聚原则

**TBD**
