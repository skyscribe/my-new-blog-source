---
layout: post
title: C++17整装待发
comments: true
categories: [language, programming, cpp]
tags: [programming, cpp, language, fp]
---
9月份对于C++社区而言绝对是个令人振奋的收获季节。

<!--more-->

先是在９月上旬的时候，语言标准化委员会完成了新的语言标准的**草案投票并取得了全票**通过（虽然有一些小的语法、修辞上的评论待修改）；
Herb Sutter第一时间在[其博客上发布了这一激动人心的消息](https://herbsutter.com/2017/09/06/c17-is-formally-approved/)：C++2017已经获得了实质性的通过静待最终发布。
值得注意的是，这是C++这门大象一般行动缓慢的语言在变更为[更敏捷的火车发布模型](https://en.wikipedia.org/wiki/Software_release_train)之后，第一次按照时间点准时发布大的语言版本。
之前可是有10多年才发布一个版本（说好的C++0x最终变成了十六进制年份的玩笑）导致开发者等到心凉自己造轮子的事情；而C++14是一个修复设计问题的小版本。

另外一个大事件则是CppCon2017社区大会的成功举办，与往常一样有一大堆的新料演讲(已经放在[这里](https://github.com/CppCon/CppCon2017))放了出来供社区消化、学习。

## C++17
作为一个按照敏捷发布模型出来的第一个大的语言版本，由于需要照顾到质量、时间节点（毕竟需要按时发布）和参考实现成熟度等因素，本来新特性不会很多。
然而作为一个语言的大版本来说，没有一定的新料自然也有滥竽充数的嫌疑；在敏捷的大背景下，谁也不愿意多等都希望马上出来一些质量够好、实现就绪马上可用的新特性；而且要不止一个，因为可供选择的编程语言实在是太多了。

值得庆幸的是，WG21标准化小组早在３月份就完成了新语言特性的草稿准备工作。

### 语言特性

很多语法糖方面的更新，可以让程序员生产率更高，包括以下这些主要的更新

#### 嵌套的命名空间声明
这是一个小小的改进，但足以节省大家很多敲击键盘和格式化缩进的烦恼。因为在比较大的项目中，经常用嵌套的命名空间来隔离API和类，之前我们不得不这样写
```cpp
namespace outer{
    namespace inner {
        namesapce module {
            //my module definitions...
        }
    }
}
```
或者为了节省空间（采用微软的换行风格有强迫症的更要哭了），直接缩略为
```cpp
namespace outer{ namespace inner{ namespace module {
    //my module definitions...
}}}
```
新标准直接允许我们写为
```cpp
namespace outer::inner::module {
    //my module definitions...
}
```
是否清爽了很多，或者有本来就应该如此的感觉？为什么没有更早支持啊。

#### `static_assert`的消息提醒参数变为可选
这个是针对之前引入的用于与编译期间静态检查机制`static_assert`的一点小修正，允许其携带的消息提醒参数被忽略，以减少编译噪音。
本来这个静态断言机制可以很好地服务于编译器多态检查，如果没问题就一路继续编译下去，如果出错，则会打印一条错误信息包含在错误诊断中，并终止编译。
新的改动允许不提供该诊断信息。

#### `auto`可以用于初始化列表的类型推导
C++11通过重用`auto`关键字来做自动类型推断，而C++17将其扩充到了初始化列表类型，并要求它符合特定的规则。即

```cpp
auto x = {1}; //decltype(x) = initializer_list<int>:
auto y = {2, 3}; //declytpe(y) = initializer_list<int, int>;
auto x1 {1}; //same as x
auto y1 {2, 3}; //ill-formed! Not a single element!
```
#### 字面量类型扩展
字面量类型具有很好的声明式风格和良好的可读性，之前的语言标准支持的类型比较有限（比如字符常量、整数、浮点常量），而C++17引入了对其他字符集的支持
- `u8'c-char'`用以支持UTF-8编码的字符常量，其类型依然是`char`类型，而其值则是用ISO10646编码的单个字符。
- `u'c-char'`用以支持UCS2编码可以支持２个字节，内部类型是`char16_t`,如 `u'\U0001f34c'`
- `U'c-char'`支持４个字节的UCS4,内部类型是`char32_t`,内部用Unicode编码，比如`U'猫'`

浮点类型的常量声明支持了更多可读性更好的格式，下边的例子
```cpp
#include <iostream>
int main()
{
  std::cout << 123.456e-67 << '\n'
            << .1E4f       << '\n'
            << 58.         << '\n'
            << 4e2         << '\n';
}
```
会输出四种方式所生命的浮点数字
```
1.23456e-65
1000
58
400
```
#### 可变长模板参数中的折叠表达式
C++11引入了可变长的模板参数，大大简化了模板元编程，而C++17则支持在变长模板参数中使用折叠或归约(函数式编程中的基本范式),
可以支持从一堆模板参数中，指明第一个而省略其他，也可以指明最后一个省略前边的。这些参数中间可以用操作符来连接，编译器需要自己负责将他们按照既定的规则串联起来。

比如这个例子
```cpp
template<typename... Args>
bool all(Args... args) { 
    //op is &&, pack parameters as ..., specified last parameter
    return (... && args); 
}

//expanded as left fold, as 
// ((true && true) && true) && false = false
bool b = all(true, true, true, false);
```

详细的定义如下
```cpp
(pack op ...) //unary right fold
(... op pack) //unary left fold
(pack op ... op init) //binary right fold
(init op ... op pack) //binary left fold 
```

一个更复杂一点的例子
```cpp
template<typename ...Args>
void printer(Args&&... args) {
    //left fold print
    (std::cout << ... << args) << '\n';
}
 
template<typename T, typename... Args>
void push_back_vec(std::vector<T>& v, Args&&... args)
{
    //binary left fold, push back from left to right, init=v
    (v.push_back(args), ...);
}
 
// compile-time endianness swap based on http://stackoverflow.com/a/36937049 
template<class T, std::size_t... N>
constexpr T bswap_impl(T i, std::index_sequence<N...>) {
  return (((i >> N*CHAR_BIT & std::uint8_t(-1)) << (sizeof(T)-1-N)*CHAR_BIT) | ...);
}
template<class T, class U = std::make_unsigned_t<T>>
constexpr U bswap(T i) {
  return bswap_impl<U>(i, std::make_index_sequence<sizeof(T)>{});
}
 
int main()
{
    printer(1, 2, 3, "abc");
 
    std::vector<int> v;
    push_back_vec(v, 6, 2, 45, 12);
    push_back_vec(v, 1, 2, 9);

    for (int i : v) std::cout << i << ' ';
 
    static_assert(bswap<std::uint16_t>(0x1234u)==0x3412u);
    static_assert(bswap<std::uint64_t>(0x0123456789abcdefULL)==0xefcdab8967452301ULL);
}
```

####
**TBD**

### 标准程序库
**TBD**
#### `std::optional<T>`

#### `std::variant<...Types>`

## CppCon2017