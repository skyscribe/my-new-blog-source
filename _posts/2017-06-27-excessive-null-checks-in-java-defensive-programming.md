---
layout: post
title: Excessive null checks in Java Defensive Programming?
categories: [programming, java]
tags: [programming, java, design, patterns]
---

最近在参与某开发小组的[团体代码审查](https://atendesigngroup.com/blog/group-code-reviews)会的时候，发现组内的一线开发工程师对于何时应该做空指针检查并没有很清晰的认识；然而这在Java社区里早已经是个老生常谈的争论 。

<!--more--> 

按照最偷懒的做法 (毕竟[懒惰是伟大程序员的美德](http://threevirtues.com/)之一)，可以对使用的对象不做检查，那么万一该指针为空，则运行期抛出的空指针异常**默认行为就会将程序给crash掉**，你的用户会很不高兴，你公司的客户会不高兴乃至投诉你的研发老板，你的老板会更加不高兴甚至于愤怒以至于半夜将你叫起来加班解决问题；试想当你拖着睡眼惺忪的躯壳爬到办公室查看日志，迷迷糊糊一看，原来是有个地方的对象引用是null指针，没有做判断导致JVM退出了。那么最自然的方案是添加个判断了，原来的代码可能是 

```java
someObj.doSth()
```
现在被改成了
```java
if (someObj != null) {
    someObj.doSth()
}
```
后边可能出现了新的问题，那么你可能依法炮制，继续加上更多的分支判断。这时候可能有个聪明的程序员跳出来说，我们不是有[防御性编程](https://en.wikipedia.org/wiki/Defensive_programming)大法吗，可以来的更彻底一些，**干脆对所有的传入对象做空指针检查**不就可以了吗？粗看起来很有道理，然而仔细想一下就会发现这里有很大的隐患。上述的检查其实对每一次对象的调用其复杂度就会增加1，如果一个类里引用了很多对象，每次都要去做判断很快使代码变得难以维护，尤其是考虑到一些稍微复杂一些的方法可能有多个出口的情况，条件判断的增多会直接导致内部状态变得难以分析。

显然对所有的对象引用做空指针检查不是一个明智的主意。那么是否有什么方法可以减少这些检查或者有其它的提高可读性的变通之道吗？

## 到底哪些情况需要判断空指针

为了探讨这个问题，我们可以详细列举一些可能需要判断的情况逐一分析一番就能做到心中有数了。因为Java语言中一切皆是对象(当然基本类型不算)，所有对象都由某个class给构造出来，所以我们**仅仅需要讨论class中涉及到的对象**即可。

### 成员对象 (field)

#### 在构造中被初始化过的成员对象

#### 没有在构造中初始化的成员对象

### 静态成员对象 (Field)

### 方法传入参数

#### 公有方法public 中的参数

#### 私有方法中的参数

### 外部对象

所谓的外部对象是这些在某个方法实现中被引用到，却并没有被类如方法传入参数，也没有被放在成员对象列表中的对象。当然如果出现这种情况，往往是全局对象的引用（要么是静态全局对象，要么是单例对象）。然而不管哪种情况下，你的class已经悄无声息地引入了**隐式依赖**，而隐式依赖在大部分情况下引入的问题比解决的问题要多。

对于这类对象，如果用现代的依赖注入方案来解决，很自然它们就和普通的成员对象没什么区别了。关键的问题是需要考虑好，是否真的必须引入这类隐式依赖就可以了，绝大部分情况下，**显示依赖比隐式依赖要好**。当然去掉了隐式依赖后，一个额外的好处是你的测试将变得更加容易了，因为不需要特殊的mock或是Stub来设置上下文了；只需要构造被测试对象的时候安插好构造参数即可。

## 变通之道
啰嗦这么多，看起来很多地方可能还是不可避免需要去做空指针检查。是否有办法做个变通，既保证逻辑正确，也能确保代码维护性不被破坏？其实回头仔细想一下，之所以有空指针异常这回事儿，根本上还不是因为**Java用异常机制来非正常情况的**处理吗，从这个角度出发，其实我们还有这些选择 

1. 用返回值而不用异常 - 然而我们是在讨论Java，虽然依然可以用返回值对象，或者类似C或者golang的error code的方式，但是如果你以这种方式写代码，其实**可维护性的负担反而加重**了,顶多是少了一些花括号而已
2. 使用新的变成范式，没错我们还有functional programming可以选择，因为Java8已经给我们送来了这个大礼 - Optional

### Optional

### 隐藏在Optional中的模式


