---
layout: post
title: 从API网关到服务网格
comments: true
categories: [design, study]
tags: [design, architecture, servicemesh, microservice]
---

API网关是微服务结构中的一个重要的边界组件，用于隔离外部用户和内部的服务部署，完成诸如安全、鉴权等集中化的功能。
边车代理则是服务网格架构中的一个重要概念，两者从逻辑上都是作为基础设施和业务的核心功能逻辑相分离的，有一定的相似性而又有很大的不同。

<!--more-->

## 微服务和API网关

微服务架构本身强调服务本身需要关注于系统的某一部分领域逻辑，并按照系统的领域问题拆分达到每一个微服务仅仅关注一个领域逻辑，
而这些微服务的整体组合成为一个大的系统；并根据不同的领域特点采用合适的软件技术实现；只要服务之间的接口协议是标准的跨语言协议即可；
大部分情况下微服务采用RESTful API（或者RPC ）加上异步消息队列来作为接口。

从架构静态设计上来说，这样解决了服务抽象和切分的问题，只是大部分业务逻辑呈现典型的前后端逻辑，一般情况下是
后端有一系列微服务组合而成，最终被部署在企业的云服务器（数据中心）上；这些云服务器可能是公有云、私有云乃至混合云。
不同的服务可能有不同的水平扩展需求，以及可用性、可靠性需求。还有一部分业务逻辑可能是在用户终端设备上，
包括浏览器页面、Android手机、iOS系统、桌面应用乃至或者其它的智能设备等。
很多情况下，前端对后端业务的访问有一些额外的需求，包括诸如安全、授权、审计等需求，并且大部分高可用的需求都是在后端上。

让每个微服务都提供这些跟领域逻辑无关的负载均衡、备份、流量控制、安全等功能，明显和**关注点分离**的设计原则相违背。
自然没有人再想回到传统SOA架构中的基于类似ESB总线的厚基础设施的工作方式上来，毕竟如果这样做，就和微服务设计的智能协议接口的思想背道而驰了。

微服务采用的思路将这些后端的具体的领域逻辑组成的微服务看作一个子系统，在这个子系统和外部服务调用者之间再加上一个网关，
让这个网关来负责这些比较通用的、和领域逻辑非紧密相关的需求；因为它本身是基于已有的服务访问的APi做的中间处理，所以被称为API网关。
这样问题就得到了解决，毕竟计算机科学中的复杂问题都可以通过加一个中间层来分而治之。

### API网关解决的主要问题

API网关主要解决以下这些微服务架构中的问题
- 前端访问的API的粒度和后端微服务的API不匹配的问题 - 典型的微服务架构可能有数百个后端微服务组成，每一个微服务可能提供很多个粒度很细的API，
而这些API可能很多不是客户端直接需要的
- 不同的客户端可能有不同的API访问版本需求，譬如桌面客户端需要访问的微服务API可能就比手机端的要丰富一些
- 不同的客户端访问可能具有不同的网络性能、带宽和时延需求，这些需求和核心领域逻辑是非紧密相关的；桌面计算机上的浏览器可以在同时发起很多条并发的HTTP请求，
而移动手机端则可能出于性能、能耗考虑需要前置其连接数量；本地局域网中的客户端访问和跨越骨干网的客户端访问的要求可能也是不一样的
- 后端微服务的动态扩展（通过启动新的服务示例增加处理能力）需要对外部访问者做隐藏，负载均衡以及集群控制逻辑需要对客户端做隐藏
- 后端微服务可能采用不同的协议，有些协议可能不需要暴露给客户端
- 安全、审计、计费等需求

### 典型的解决方法

一种常用的做法是在前端和后端之间，让API网关成为一个单一的访问点，它可以处理两者的请求，
处理请求可以被转发或者内部路由到某个服务节点上，也可以被扇出到多个微服务实例上做负载均衡，或者根据安全配置直接拒绝。

![api_gw_solution](http://microservices.io/i/apigateway.jpg)

实现上，API网关也可以根据客户端的不同而暴露不同的API，比如Netflix的API 网关内部有依据客户端的不同而动态选择适配的代码，使不同的客户端可以得到不同的访问API。

![netflix_api_gw](https://cdn-images-1.medium.com/max/800/1*ceTE4I9CbLv_cRPQEyrkMw.png)

### 基于前端的变种

另外一种解决方案是依据前端的不同，设置多个API网关，每个网关针对一种客户端提供一个具体的API网关；这些网关分别和后端的服务交互完成整个处理流程。
其架构如下图

![api_gw_backend_for_frontend](http://microservices.io/i/bffe.png)

### API网关的特点

API网关是对后端微服务的整体封装，它提供了一个受控的API环境，由此
- API网关会调用被其隐藏的更下游的微服务，并确保这些调用满足高度可用和弹性设计模式，包括断路控制、超时控制、负载均衡和自动切换等。
很多API网关实现会包含这些基本弹性设计功能。
- API网关往往也提供对服务发现和注册，性能指标统计、监控、分布式日志、跟踪和安全审计等功能
- 同时API网关也会和API发布、计费等一些通用的API管理功能相结合，共同提供服务

## 无服务器架构和服务网格

基于上述讨论的微服务架构自身在通用基础设施方面的不足，以及API网关本身容易成为系统灵活性和扩展性的瓶颈的隐忧，无服务器架构用服务网格来作为底层基础设施的封装，
使每个微服务都有一个基础设施的部分负责上述API网关完成的通用功能，使得系统设计的灵活性得到更大的提高。
无服务器架构在很多场景下被称为是"下一代微服务"；可以看作它是微服务架构的进一步延伸; 其本身是为了更好的满足云原生应用的要求而被提出的。

### 云原生应用

**TBD**

### 服务网格的基本思路

服务网格的基本想法是，让微服务的设计者无需再关心服务于服务之间如通过复杂的拓扑结构进行相互通信；作为一个新的抽象层，
服务网格提供一个轻量级的代理来和微服务一一绑定，并使微服务本身无需关注该代理的存在。这些代理总是处于一个一个具体的微服务的边界上，所以被称为边车代理。
这些边车代理自身可以形成一个网格，之间可以相互通信，设置路由，进行超时、断路器控制，进行安全管控等。

服务网格的基本结构可以参考下图

![service_mesh_basic](http://philcalcado.com/img/service-mesh/6-a.png)

某种程度上来说，服务网格仍然是想用轻量级的方式来提供ESB类似的能力，并不破坏架构的灵活性以更敏捷的方式架构复杂多变的软件系统。

显然边车代理的功能和API网关有某些逻辑上相似的地方，同时边车代理可以提供更灵活的配置和管理。
作为一个轻量级的代理，边车代理需要和微服务本身绑定在一起，部署在同一个容器或者VM中。

## 边车代理和API网关的比较

**TBD**

## 边车代理的几种实现主要实现

**TBD**

### Linkerd

**TBD**


### lstio

**TBD**


### Conduit


**TBD**

## 参考
1. [API Gateway Pattern](http://microservices.io/patterns/apigateway.html)
2. [Netflix Techblog - Embrace the differences: Inside the Netflix API Redesign](https://medium.com/netflix-techblog/embracing-the-differences-inside-the-netflix-api-redesign-15fd8b3dc49d)
3. [Service Mesh vs API Gateway](https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56)
4. [Buoyant blog - what's a service mesh and why I need one?](https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/)
5. [Pattern: service mesh](http://philcalcado.com/2017/08/03/pattern_service_mesh.html)
