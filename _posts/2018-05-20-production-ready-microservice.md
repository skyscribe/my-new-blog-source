---
layout: post
title: 标准化和生产环境就绪的微服务
comments: true
categories: [design, architecture]
tags: [design, architecture, microservice, standardization]
---

微服务作为一种分布式的软件架构风格几乎已经席卷软件开发的各个角落；尽管它从被明确提出之后也很快经历了大量的质疑、批判乃至否定；
然而背后实践这一符合康威定律的简单（将问题分而治之）而又复杂（需要解决服务本身引起的的许多复杂的基础设施问题）的架构风格的组织却与日俱增。
其原因也不过是随着云计算技术的逐步深入，分布式架构成为最简单的选择，因为大部分情况下处于成本的考量，我们更需要水平扩展而不是垂直扩展；
微服务引入过程中的**一些痛点也随着越来越多云原生应用的开源组件的出现而得到缓解**。尝试将微服务实践标准化以降低实施成本的努力也变得不再是“空中楼阁”了，
走的人多了，必然有些更容易走的"直路"显现出来。

<!--more-->

## 为什么需要标准化

Susan J.Fowler作为一名来自Uber的站点可靠性工程师(Site Reliability Engineer)见证了Uber自身将其庞大而又复杂的单体API剥离成逾千个微服务的，
并达到超过85%的微服务团队并无配备SRE这一角色也能确保自己的服务运行良好。同时她也见证了微服务团队（尤其是大型微服务架构）中SRE工程师所面临的巨大挑战：

- 对SRE本身的能力要求是全方位的，他/她必须是包括软件工程、系统工程、软件架构等多个方面的综合性专家
- 在有成百上千个微服务组成的企业应用中，大部分的团队更本不可能拥有SRE的资源；SRE也不太可能熟悉哪怕系统中大部分微服务的关键细节
- SRE需要对系统整体的可靠性负责，然而任何一个微服务的SLA水平下降都可能带来整个系统的SLA下降；在大多数团队不配备SRE的情况下，
如何保证日常的开发中新引入的功能不会破坏整体的可靠性、可用性和性能的关键指标，或者如何做有效的回归和可靠性测试，并在发现可能的失败情况下，
及早地回退引起整体质量下降的服务代码，都是一个看起来几乎不可能的任务

Susan希望他们可以找到一种简单而又直接的方法来定义微服务实践的规范程度，即一种简单而又可靠的标准，使得组织中的每一个微服务团队都可以仅仅需要遵循这些标准就可以交付符合SLA要求的服务，
同时还保有微服务架构本身带来的诸如自由选择编程语言、技术栈的优势。这一套标准其实是用一系列检查列表（CheckList)的方式提供，微服务团队在提交自己的实现之前检查这些列表，
确保所有的实现都能满足列表的要求的情况下才将代码引入到生产环境中；这样整个系统的SLA就可以得到保证。

## 基本原则

Susan他们给出的标准化微服务的标准大概可以划分到八个大的基本原则之下，每个微服务必须满足
- 稳定
- 可靠
- 可扩展
- 容错
- 性能良好
- 被合理监控
- 有良好的文档
- 容灾就绪

在这些大的原则之下，Susan他们还详细定义了每一个原则里面的详细列表，并要求每一个原则必须是**可以量化**以方便提供度量结果，
从而可以极大地提高微服务系统的可用性。所有满足这些条件的微服务，可以被认为是生产就绪的。

### 微服务生态系统

微服务从来都不是孤立从在的，它们被构建、运行和交互的环境就是它们生存的环境；大型的微服务系统的生存环境就像是一大片森林，一个沙漠或者一个大海；
将这个环境考虑为一个生态系统往往更有利于我们采用微服务风格来架构我们的应用系统。

设计良好的可持续的微服务生态系统往往会尽力用一个基础设施层将底层的细节和上层的微服务应用相隔离开；这样微服务的开发人员可以像开发一个单体应用一样，
使用他们喜欢的技术和编程语言，自己决定服务内部的软件架构；并不需要过多考虑底层基础设施这些细节，比如操作系统、网络、存储等复杂的基础知识。
自然地，将这些基础设施保持地稳定、高效、可扩展并能良好地容错就成为一个非常基本的需求。

微服务的生态系统可以简单地划分为四个层次，尽管有时候层次之间的界限并不是那么清晰而绝对
- 硬件层
- 通信层
- 软件应用平台
- 微服务层

最底层的部分是硬件层，它负责处理诸如实际的物理资源，包括真实硬件、网络节点，乃至数据中心的机架、交换机或者SDN网络、存储设备等；这些设施可以是自己搭建的数据中心，
也可以是从其它的云服务商处租赁来，比如AWS EC2、Google GCP、MS Azure等。所有这些相关的细节被硬件层所管理。
硬件之上的操作系统，以及相关的配置，资源隔离和抽象设置，主机层面的日志、监控也需要被这一层统一提供；尽管集体的系统选择和日志、监控工具可能由企业应用具体的环境来选择决定。

硬件层之上的是通信层；该层本质上参与了上面两层的交互，因为所有微服务乃至软件应用平台的交互都被这一层所处理。从严格分层的角度来看，似乎这一层有些定义不太良好。
幸运的是，基本的要素是清晰的，它需要处理诸如网络设置、DNS解析、RPC设施、API端点控制、服务发现和注册、负载均衡等微服务底层治理设施。

作为第三层的软件平台层负责处理所有微服务共享的内部工具、共享的基础服务等。这一层必须提供整个系统范围内共享的基础应用软件设施，使得微服务团队不需要自己设计和维护他们自身微服务逻辑之外的复杂软件。
设计良好的软件平台需要提供内部开发者共同使用的方便的内部开发工具,自动化构建和测试平台，中心化的自动部署和发布方案，比如一些DevOps工具，自动发布工具，
微服务层面的日志、监控工具等。

微服务层处于这个生态系统的最上层，主要负责其职责范围内的业务逻辑和API实现，并和底层的硬件、服务治理设施、通用应用软件平台隔离开。
唯一一个没有和下面几层完全隔离的就是微服务自身的配置。一种常见的做法是将所有的微服务的配置都用中心化的方式来管理和控制；然而这在大型的微服务软件中可能带来巨大的问题，
因为当微服务人员需要修改其配置的时候，往往不得不修改其下面几层的文件（因为被中心化托管），由于微服务数量庞大，开发人员往往不知应该改动哪里或者遗漏重要的配置。
这种情况下，更合理的方案是将各个微服务的配置放在自己的代码库中，然后让底层的工具或者平台可以访问这些配置文件。

## 可靠性
**TBD**
