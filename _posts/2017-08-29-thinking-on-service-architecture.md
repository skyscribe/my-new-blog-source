---
layout: post
title: 架构服务化的一点思考
comments: true
categories: [design]
tags: [programming, design, architecture, SOA, microservice, monolith]
---

微服务是个非常热门的话题，最近几年随着互联网的深入演进和云计算的逐渐普及，几乎所有的公司、技术社区、组织都是言必谈微服务；
似乎没有微服务都不好意思说自己能保持技术能力的与时俱进了。这厢微服务还没有完全在实践中铺开，那边潮头Amazon又挑起了无服务器架构的大旗，引来无数人的关注。
本文试图对这些概念和架构思想做一简单的分析和梳理。

<!--more-->

## 服务架构的前世今生
考虑到微服务其实仍然是基于服务的架构方式，既然有“微”则必然有“宏”与之对应;只是之前大家都是直接叫基于服务的架构而已。

### 没有服务的架构
在软件工程的早期洪荒时代，所有的软件都是按照最原始的模块化思路组织和开发的;那时候编程语言基本是C/C++的，各个子部分之间采用头文件的方式来模拟相互之间的接口，源代码文件作为实现之间的隔离。
这种情况下，各个逻辑**子部分的约束基本是比较弱的**，要么是依赖于组织内部的约定，要么是依赖于一些比较hack的方式。
这种方式可以认为是基于内部API和调用约定的无服务的架构方式。应用程序要么是独立组织的，要么是通过API定义好接口，然后各个模块分别开发，再统一连接起来形成最终的可执行程序。

这么做的弊端非常明显，因为接口的定义极大地影响系统集成的效率，以至于各个模块独立开发的时候没什么问题，一旦到了集成阶段则困难重重，迟迟不能发布出来。
个人觉得这个问题的本质在于，**完美的API定义是非常困难的**，需要极高的技术能力和对问题业务领域的深刻分析。

### Unix编程哲学
Unix社区则推荐采用多进程和管道的方式开发复杂应用，每个小程序负责一件事儿，进程之间采用管道链接输入和输出。
由于程序之间的输入和输出缺乏统一的规范化，Unix哲学推荐用基于文本的进程间接口来组织程序，以便调试和分析、诊断等。

美中不足的是，它对于具体怎么实践这些基于文本的即可没有统一的建议或规定，因为文本的格式是需要被程序去理解的，其中应该包含这负责的业务逻辑而不是简单的计算机字符串，简单按照这种设计哲学去开发应用程序依然是困难重重。
另外一个难题是，Unix程序都假设是基于单个物理机器的运行环境，因为早期的Unix都是大型机，它无法预料到后期廉价PC的崛起。
各种围绕本地IPC机制设计的管道、系统信号等通信方式和TCP/IP的网络环境有很大的差异，导致代码并不能很好的复用。

然而Unix设计哲学所推荐的这种**系统职责分割方式和基于文本的协议交互对后来的微服务有巨大的影响**。

### 分布式对象技术
90年代后期，微软提出了组件化开发的COM以及DCOM开发模型，使用接口来达到软件复用，最终程序通过接口定义和动态链接和查找实现分布式开发。
而Java社区则走向了分布式对象的模式，提出了JavaEE并和C++社区的CORBA对象代理技术兼容。
这种情况下，对象分布式技术的着眼点是基于OOA分析的划分。

### SOA架构

JavaEE提出也提出了基于服务的架构方式，它在很多场合也往往被成为**Big Web Service**,其典型特征如下
- 复杂的系统被分割为一个一个相互通信的接口
- 使用WSDL来定义服务和服务之间的接口的通信
- 该**通信方式是基于HTTP+XML+SOAP封装**，消息模型为**基于请求/响应**的RPC模型，其中定义了消息通信的消息结构和通信端点抽象;
支持通过工具将WSDL转换为对应的代码，简化接口编码、解码的工作量
- 高级特性支持安全、服务注册和发现，以及多版本向后兼容等

SOA极大地提高了企业应用开发的效率，采用SOA架构的软件曾被认为是面向未来的，当时的业界对SOA的期望一如今天对微服务的期许。

它的**缺陷在于过于笨重**，部分原因在于XML本身的臃肿和复杂;实际场景中可能用于XML/SOAP解析和校验的开销变得过于巨大以至于性能很糟糕。
XML过于臃肿的特性导致大家追求通过压缩消息来节省网络带宽以优化性能，然而压缩和解压反而需要消耗额外的CPU资源。
另一部分则是因为JAX-WS规范的一些高级特性是可选的，而**某些特性是由跳过了HTTP协议直接在SOAP中实现**的;然而HTTP协议本身也提供了丰富的特性，弃之不用自然会导致资源的浪费。

此外基于RPC的通信方式并不是在所有方式下都适合，因为其隐含的模型是同步的请求、响应;实际的业务逻辑都直接定义在这些接口中，造成**业务逻辑和接口直接产生了依赖**。如果频繁的因为需求变动导致WSDL接口定义变更，后向兼容又会变成一个沉重的负担。当然这个也是基于服务的方式必须要面对的问题。

### WEB技术的发展和RESTful架构风格
**T.B.D**

### 领域驱动开发
Eric Evans通过他划时代的《领域驱动开发》一书将面向对象技术推向了新的深度;通过提倡业务统一语言，领域对象的识别和绑定上下文的分析等技术，
实现了软件架构能更好地适应业务的演进需要。
恰当的领域职责划分，以及领域专家和软件技术专家的通力合作和互相理解更容易生产出可维护、易扩展、更容易拥抱实际商业环境变化的系统。

### 软件开发方法学支持
敏捷软件开发和持续集成等实践在过去的近20年几乎席卷了软件开发领域的大部分角落。
持续发布以及DevOps运动则进一步减小了软件开发的反馈周期，深刻地改变了大部分传统软件测试人员的工作方式和线上运维的成本结构。

传统的先设计，再编码内部测试，最后再搞一个旷日持久的大集成及系统测试的开发模式再也不能适应追求快速响应的企业软件市场。
追求更快的发布速度和上线速度，成为影响企业成败的一个关键因素之一。

### 站在巨人肩上的微服务
从某些方面看，微服务架构可谓是站在巨人的肩上诞生的新的弄潮儿;
它是在面向对象深入发展到领域驱动设计的基础上，随着WEB技术的深度发展和RESTful的日益流行而自然产生的。其特点和要求如下
- 采用**业务领域特点来划分服务边界**，其基本思路是DDD的
- 服务的力度要尽量的小，符合Unix的编程哲学，每个服务只做一件事并将其做好;有的建议是一个服务最好能被一个小的开发团队（比如Scrum的5～7人模型）负责分析、设计、开发、测试、发布等所有工作。
- **每个服务是一个进程**，对外提供基于RESTful风格的HTTP服务（也有基于Protobuf的gRPC微服务框架）
- 服务接口提供多个版本，每个服务负责自己的向后兼容性，方便**独立开发和部署**
**T.B.D**

## 微服务是“银弹”吗
**T.B.D**

### 微服务适合那些人、组织

### 先决条件

### 微服务与云计算

### 未来的方向

T.B.D.

